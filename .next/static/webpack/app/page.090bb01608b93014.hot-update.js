"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useChat.ts":
/*!******************************!*\
  !*** ./src/hooks/useChat.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChat: function() { return /* binding */ useChat; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/api */ \"(app-pages-browser)/./src/utils/api.ts\");\n\n\nconst useChat = ()=>{\n    const [chatState, setChatState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        messages: [],\n        isLoading: false,\n        error: null\n    });\n    const addMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((message)=>{\n        const newMessage = {\n            ...message,\n            id: Date.now().toString(),\n            timestamp: new Date()\n        };\n        setChatState((prev)=>({\n                ...prev,\n                messages: [\n                    ...prev.messages,\n                    newMessage\n                ]\n            }));\n        return newMessage.id;\n    }, []);\n    const updateMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((messageId, updates)=>{\n        setChatState((prev)=>({\n                ...prev,\n                messages: prev.messages.map((msg)=>msg.id === messageId ? {\n                        ...msg,\n                        ...updates\n                    } : msg)\n            }));\n    }, []);\n    const sendMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (content, threadId)=>{\n        if (!content.trim() || chatState.isLoading) return;\n        setChatState((prev)=>({\n                ...prev,\n                isLoading: true,\n                error: null\n            }));\n        // Add user message\n        const userMessageId = addMessage({\n            role: \"user\",\n            content: content.trim()\n        });\n        // Add assistant message placeholder\n        const assistantMessageId = addMessage({\n            role: \"assistant\",\n            content: \"\",\n            isStreaming: true\n        });\n        try {\n            // Filter out error messages and only include valid conversation messages\n            const conversationHistory = chatState.messages.filter((msg)=>!msg.content.startsWith(\"Error:\") && msg.content.trim() !== \"\").map((msg)=>({\n                    role: msg.role,\n                    content: msg.content\n                }));\n            // Add the new user message to conversation history\n            conversationHistory.push({\n                role: \"user\",\n                content: content.trim()\n            });\n            const stream = await (0,_utils_api__WEBPACK_IMPORTED_MODULE_1__.sendMessageToWeatherAgent)(conversationHistory, threadId);\n            let accumulatedContent = \"\";\n            await (0,_utils_api__WEBPACK_IMPORTED_MODULE_1__.parseStreamingResponse)(stream, (contentChunk)=>{\n                accumulatedContent += contentChunk;\n                updateMessage(assistantMessageId, {\n                    content: accumulatedContent,\n                    isStreaming: true\n                });\n            }, ()=>{\n                updateMessage(assistantMessageId, {\n                    content: accumulatedContent,\n                    isStreaming: false\n                });\n                setChatState((prev)=>({\n                        ...prev,\n                        isLoading: false\n                    }));\n            }, (error)=>{\n                updateMessage(assistantMessageId, {\n                    content: \"Error: \".concat(error),\n                    isStreaming: false\n                });\n                setChatState((prev)=>({\n                        ...prev,\n                        isLoading: false,\n                        error\n                    }));\n            });\n        } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : \"Failed to send message\";\n            updateMessage(assistantMessageId, {\n                content: \"Error: \".concat(errorMessage),\n                isStreaming: false\n            });\n            setChatState((prev)=>({\n                    ...prev,\n                    isLoading: false,\n                    error: errorMessage\n                }));\n        }\n    }, [\n        chatState.messages,\n        chatState.isLoading,\n        addMessage,\n        updateMessage\n    ]);\n    const clearChat = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setChatState({\n            messages: [],\n            isLoading: false,\n            error: null\n        });\n    }, []);\n    const searchMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((query)=>{\n        if (!query.trim()) return chatState.messages;\n        return chatState.messages.filter((message)=>message.content.toLowerCase().includes(query.toLowerCase()));\n    }, [\n        chatState.messages\n    ]);\n    return {\n        ...chatState,\n        sendMessage,\n        clearChat,\n        searchMessages,\n        addMessage,\n        updateMessage\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TztZQUNmLE1BQU04QixlQUFlOUIsaUJBQWlCK0IsUUFBUS9CLE1BQU1FLE9BQU8sR0FBRztZQUM5RFEsY0FBY1csb0JBQW9CO2dCQUNqQ0wsU0FBUyxVQUF1QixPQUFiYztnQkFDbkJSLGFBQWE7WUFDZDtZQUNBekIsYUFBYVksQ0FBQUEsT0FBUztvQkFDckIsR0FBR0EsSUFBSTtvQkFDUFYsV0FBVztvQkFDWEMsT0FBTzhCO2dCQUNSO1FBQ0Q7SUFDRCxHQUFHO1FBQUNsQyxVQUFVRSxRQUFRO1FBQUVGLFVBQVVHLFNBQVM7UUFBRUU7UUFBWVM7S0FBYztJQUV2RSxNQUFNc0IsWUFBWXhDLGtEQUFXQSxDQUFDO1FBQzdCSyxhQUFhO1lBQ1pDLFVBQVUsRUFBRTtZQUNaQyxXQUFXO1lBQ1hDLE9BQU87UUFDUjtJQUNELEdBQUcsRUFBRTtJQUVMLE1BQU1pQyxpQkFBaUJ6QyxrREFBV0EsQ0FBQyxDQUFDMEM7UUFDbkMsSUFBSSxDQUFDQSxNQUFNaEIsSUFBSSxJQUFJLE9BQU90QixVQUFVRSxRQUFRO1FBRTVDLE9BQU9GLFVBQVVFLFFBQVEsQ0FBQzBCLE1BQU0sQ0FBQ3RCLENBQUFBLFVBQ2hDQSxRQUFRYyxPQUFPLENBQUNtQixXQUFXLEdBQUdDLFFBQVEsQ0FBQ0YsTUFBTUMsV0FBVztJQUUxRCxHQUFHO1FBQUN2QyxVQUFVRSxRQUFRO0tBQUM7SUFFdkIsT0FBTztRQUNOLEdBQUdGLFNBQVM7UUFDWm1CO1FBQ0FpQjtRQUNBQztRQUNBaEM7UUFDQVM7SUFDRDtBQUNELEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL3VzZUNoYXQudHM/YmE3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgTWVzc2FnZSwgQ2hhdFN0YXRlIH0gZnJvbSAnQC90eXBlcydcclxuaW1wb3J0IHsgc2VuZE1lc3NhZ2VUb1dlYXRoZXJBZ2VudCwgcGFyc2VTdHJlYW1pbmdSZXNwb25zZSB9IGZyb20gJ0AvdXRpbHMvYXBpJ1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZUNoYXQgPSAoKSA9PiB7XHJcblx0Y29uc3QgW2NoYXRTdGF0ZSwgc2V0Q2hhdFN0YXRlXSA9IHVzZVN0YXRlPENoYXRTdGF0ZT4oe1xyXG5cdFx0bWVzc2FnZXM6IFtdLFxyXG5cdFx0aXNMb2FkaW5nOiBmYWxzZSxcclxuXHRcdGVycm9yOiBudWxsXHJcblx0fSlcclxuXHJcblx0Y29uc3QgYWRkTWVzc2FnZSA9IHVzZUNhbGxiYWNrKChtZXNzYWdlOiBPbWl0PE1lc3NhZ2UsICdpZCcgfCAndGltZXN0YW1wJz4pID0+IHtcclxuXHRcdGNvbnN0IG5ld01lc3NhZ2U6IE1lc3NhZ2UgPSB7XHJcblx0XHRcdC4uLm1lc3NhZ2UsXHJcblx0XHRcdGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXHJcblx0XHRcdHRpbWVzdGFtcDogbmV3IERhdGUoKVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRzZXRDaGF0U3RhdGUocHJldiA9PiAoe1xyXG5cdFx0XHQuLi5wcmV2LFxyXG5cdFx0XHRtZXNzYWdlczogWy4uLnByZXYubWVzc2FnZXMsIG5ld01lc3NhZ2VdXHJcblx0XHR9KSlcclxuXHRcdFxyXG5cdFx0cmV0dXJuIG5ld01lc3NhZ2UuaWRcclxuXHR9LCBbXSlcclxuXHJcblx0Y29uc3QgdXBkYXRlTWVzc2FnZSA9IHVzZUNhbGxiYWNrKChtZXNzYWdlSWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxNZXNzYWdlPikgPT4ge1xyXG5cdFx0c2V0Q2hhdFN0YXRlKHByZXYgPT4gKHtcclxuXHRcdFx0Li4ucHJldixcclxuXHRcdFx0bWVzc2FnZXM6IHByZXYubWVzc2FnZXMubWFwKG1zZyA9PiBcclxuXHRcdFx0XHRtc2cuaWQgPT09IG1lc3NhZ2VJZCA/IHsgLi4ubXNnLCAuLi51cGRhdGVzIH0gOiBtc2dcclxuXHRcdFx0KVxyXG5cdFx0fSkpXHJcblx0fSwgW10pXHJcblxyXG5cdGNvbnN0IHNlbmRNZXNzYWdlID0gdXNlQ2FsbGJhY2soYXN5bmMgKGNvbnRlbnQ6IHN0cmluZywgdGhyZWFkSWQ/OiBzdHJpbmcpID0+IHtcclxuXHRcdGlmICghY29udGVudC50cmltKCkgfHwgY2hhdFN0YXRlLmlzTG9hZGluZykgcmV0dXJuXHJcblxyXG5cdFx0c2V0Q2hhdFN0YXRlKHByZXYgPT4gKHsgLi4ucHJldiwgaXNMb2FkaW5nOiB0cnVlLCBlcnJvcjogbnVsbCB9KSlcclxuXHJcblx0XHQvLyBBZGQgdXNlciBtZXNzYWdlXHJcblx0XHRjb25zdCB1c2VyTWVzc2FnZUlkID0gYWRkTWVzc2FnZSh7XHJcblx0XHRcdHJvbGU6ICd1c2VyJyxcclxuXHRcdFx0Y29udGVudDogY29udGVudC50cmltKClcclxuXHRcdH0pXHJcblxyXG5cdFx0Ly8gQWRkIGFzc2lzdGFudCBtZXNzYWdlIHBsYWNlaG9sZGVyXHJcblx0XHRjb25zdCBhc3Npc3RhbnRNZXNzYWdlSWQgPSBhZGRNZXNzYWdlKHtcclxuXHRcdFx0cm9sZTogJ2Fzc2lzdGFudCcsXHJcblx0XHRcdGNvbnRlbnQ6ICcnLFxyXG5cdFx0XHRpc1N0cmVhbWluZzogdHJ1ZVxyXG5cdFx0fSlcclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IGVycm9yIG1lc3NhZ2VzIGFuZCBvbmx5IGluY2x1ZGUgdmFsaWQgY29udmVyc2F0aW9uIG1lc3NhZ2VzXHJcblx0XHRcdGNvbnN0IGNvbnZlcnNhdGlvbkhpc3RvcnkgPSBjaGF0U3RhdGUubWVzc2FnZXNcclxuXHRcdFx0XHQuZmlsdGVyKG1zZyA9PiAhbXNnLmNvbnRlbnQuc3RhcnRzV2l0aCgnRXJyb3I6JykgJiYgbXNnLmNvbnRlbnQudHJpbSgpICE9PSAnJylcclxuXHRcdFx0XHQubWFwKG1zZyA9PiAoe1xyXG5cdFx0XHRcdFx0cm9sZTogbXNnLnJvbGUsXHJcblx0XHRcdFx0XHRjb250ZW50OiBtc2cuY29udGVudFxyXG5cdFx0XHRcdH0pKVxyXG5cclxuXHRcdFx0Ly8gQWRkIHRoZSBuZXcgdXNlciBtZXNzYWdlIHRvIGNvbnZlcnNhdGlvbiBoaXN0b3J5XHJcblx0XHRcdGNvbnZlcnNhdGlvbkhpc3RvcnkucHVzaCh7XHJcblx0XHRcdFx0cm9sZTogJ3VzZXInIGFzIGNvbnN0LFxyXG5cdFx0XHRcdGNvbnRlbnQ6IGNvbnRlbnQudHJpbSgpXHJcblx0XHRcdH0pXHJcblxyXG5cdFx0XHRjb25zdCBzdHJlYW0gPSBhd2FpdCBzZW5kTWVzc2FnZVRvV2VhdGhlckFnZW50KGNvbnZlcnNhdGlvbkhpc3RvcnksIHRocmVhZElkKVxyXG5cdFx0XHRcclxuXHRcdFx0bGV0IGFjY3VtdWxhdGVkQ29udGVudCA9ICcnXHJcblxyXG5cdFx0XHRhd2FpdCBwYXJzZVN0cmVhbWluZ1Jlc3BvbnNlKFxyXG5cdFx0XHRcdHN0cmVhbSxcclxuXHRcdFx0XHQoY29udGVudENodW5rOiBzdHJpbmcpID0+IHtcclxuXHRcdFx0XHRcdGFjY3VtdWxhdGVkQ29udGVudCArPSBjb250ZW50Q2h1bmtcclxuXHRcdFx0XHRcdHVwZGF0ZU1lc3NhZ2UoYXNzaXN0YW50TWVzc2FnZUlkLCB7XHJcblx0XHRcdFx0XHRcdGNvbnRlbnQ6IGFjY3VtdWxhdGVkQ29udGVudCxcclxuXHRcdFx0XHRcdFx0aXNTdHJlYW1pbmc6IHRydWVcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHQoKSA9PiB7XHJcblx0XHRcdFx0XHR1cGRhdGVNZXNzYWdlKGFzc2lzdGFudE1lc3NhZ2VJZCwge1xyXG5cdFx0XHRcdFx0XHRjb250ZW50OiBhY2N1bXVsYXRlZENvbnRlbnQsXHJcblx0XHRcdFx0XHRcdGlzU3RyZWFtaW5nOiBmYWxzZVxyXG5cdFx0XHRcdFx0fSlcclxuXHRcdFx0XHRcdHNldENoYXRTdGF0ZShwcmV2ID0+ICh7IC4uLnByZXYsIGlzTG9hZGluZzogZmFsc2UgfSkpXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHQoZXJyb3I6IHN0cmluZykgPT4ge1xyXG5cdFx0XHRcdFx0dXBkYXRlTWVzc2FnZShhc3Npc3RhbnRNZXNzYWdlSWQsIHtcclxuXHRcdFx0XHRcdFx0Y29udGVudDogYEVycm9yOiAke2Vycm9yfWAsXHJcblx0XHRcdFx0XHRcdGlzU3RyZWFtaW5nOiBmYWxzZVxyXG5cdFx0XHRcdFx0fSlcclxuXHRcdFx0XHRcdHNldENoYXRTdGF0ZShwcmV2ID0+ICh7IFxyXG5cdFx0XHRcdFx0XHQuLi5wcmV2LCBcclxuXHRcdFx0XHRcdFx0aXNMb2FkaW5nOiBmYWxzZSwgXHJcblx0XHRcdFx0XHRcdGVycm9yIFxyXG5cdFx0XHRcdFx0fSkpXHJcblx0XHRcdFx0fVxyXG5cdFx0XHQpXHJcblx0XHR9IGNhdGNoIChlcnJvcikge1xyXG5cdFx0XHRjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdGYWlsZWQgdG8gc2VuZCBtZXNzYWdlJ1xyXG5cdFx0XHR1cGRhdGVNZXNzYWdlKGFzc2lzdGFudE1lc3NhZ2VJZCwge1xyXG5cdFx0XHRcdGNvbnRlbnQ6IGBFcnJvcjogJHtlcnJvck1lc3NhZ2V9YCxcclxuXHRcdFx0XHRpc1N0cmVhbWluZzogZmFsc2VcclxuXHRcdFx0fSlcclxuXHRcdFx0c2V0Q2hhdFN0YXRlKHByZXYgPT4gKHsgXHJcblx0XHRcdFx0Li4ucHJldiwgXHJcblx0XHRcdFx0aXNMb2FkaW5nOiBmYWxzZSwgXHJcblx0XHRcdFx0ZXJyb3I6IGVycm9yTWVzc2FnZSBcclxuXHRcdFx0fSkpXHJcblx0XHR9XHJcblx0fSwgW2NoYXRTdGF0ZS5tZXNzYWdlcywgY2hhdFN0YXRlLmlzTG9hZGluZywgYWRkTWVzc2FnZSwgdXBkYXRlTWVzc2FnZV0pXHJcblxyXG5cdGNvbnN0IGNsZWFyQ2hhdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuXHRcdHNldENoYXRTdGF0ZSh7XHJcblx0XHRcdG1lc3NhZ2VzOiBbXSxcclxuXHRcdFx0aXNMb2FkaW5nOiBmYWxzZSxcclxuXHRcdFx0ZXJyb3I6IG51bGxcclxuXHRcdH0pXHJcblx0fSwgW10pXHJcblxyXG5cdGNvbnN0IHNlYXJjaE1lc3NhZ2VzID0gdXNlQ2FsbGJhY2soKHF1ZXJ5OiBzdHJpbmcpID0+IHtcclxuXHRcdGlmICghcXVlcnkudHJpbSgpKSByZXR1cm4gY2hhdFN0YXRlLm1lc3NhZ2VzXHJcblx0XHRcclxuXHRcdHJldHVybiBjaGF0U3RhdGUubWVzc2FnZXMuZmlsdGVyKG1lc3NhZ2UgPT5cclxuXHRcdFx0bWVzc2FnZS5jb250ZW50LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocXVlcnkudG9Mb3dlckNhc2UoKSlcclxuXHRcdClcclxuXHR9LCBbY2hhdFN0YXRlLm1lc3NhZ2VzXSlcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdC4uLmNoYXRTdGF0ZSxcclxuXHRcdHNlbmRNZXNzYWdlLFxyXG5cdFx0Y2xlYXJDaGF0LFxyXG5cdFx0c2VhcmNoTWVzc2FnZXMsXHJcblx0XHRhZGRNZXNzYWdlLFxyXG5cdFx0dXBkYXRlTWVzc2FnZVxyXG5cdH1cclxufVxyXG5cclxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJzZW5kTWVzc2FnZVRvV2VhdGhlckFnZW50IiwicGFyc2VTdHJlYW1pbmdSZXNwb25zZSIsInVzZUNoYXQiLCJjaGF0U3RhdGUiLCJzZXRDaGF0U3RhdGUiLCJtZXNzYWdlcyIsImlzTG9hZGluZyIsImVycm9yIiwiYWRkTWVzc2FnZSIsIm1lc3NhZ2UiLCJuZXdNZXNzYWdlIiwiaWQiLCJEYXRlIiwibm93IiwidG9TdHJpbmciLCJ0aW1lc3RhbXAiLCJwcmV2IiwidXBkYXRlTWVzc2FnZSIsIm1lc3NhZ2VJZCIsInVwZGF0ZXMiLCJtYXAiLCJtc2ciLCJzZW5kTWVzc2FnZSIsImNvbnRlbnQiLCJ0aHJlYWRJZCIsInRyaW0iLCJ1c2VyTWVzc2FnZUlkIiwicm9sZSIsImFzc2lzdGFudE1lc3NhZ2VJZCIsImlzU3RyZWFtaW5nIiwiY29udmVyc2F0aW9uSGlzdG9yeSIsImZpbHRlciIsInN0YXJ0c1dpdGgiLCJwdXNoIiwic3RyZWFtIiwiYWNjdW11bGF0ZWRDb250ZW50IiwiY29udGVudENodW5rIiwiZXJyb3JNZXNzYWdlIiwiRXJyb3IiLCJjbGVhckNoYXQiLCJzZWFyY2hNZXNzYWdlcyIsInF1ZXJ5IiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useChat.ts\n"));

/***/ })

});