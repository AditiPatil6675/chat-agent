"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useChat.ts":
/*!******************************!*\
  !*** ./src/hooks/useChat.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChat: function() { return /* binding */ useChat; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/api */ \"(app-pages-browser)/./src/utils/api.ts\");\n\n\nconst useChat = ()=>{\n    const [chatState, setChatState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        messages: [],\n        isLoading: false,\n        error: null\n    });\n    const addMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((message)=>{\n        const newMessage = {\n            ...message,\n            id: Date.now().toString(),\n            timestamp: new Date()\n        };\n        setChatState((prev)=>({\n                ...prev,\n                messages: [\n                    ...prev.messages,\n                    newMessage\n                ]\n            }));\n        return newMessage.id;\n    }, []);\n    const updateMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((messageId, updates)=>{\n        setChatState((prev)=>({\n                ...prev,\n                messages: prev.messages.map((msg)=>msg.id === messageId ? {\n                        ...msg,\n                        ...updates\n                    } : msg)\n            }));\n    }, []);\n    const sendMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (content, threadId)=>{\n        if (!content.trim() || chatState.isLoading) return;\n        setChatState((prev)=>({\n                ...prev,\n                isLoading: true,\n                error: null\n            }));\n        // Add user message\n        const userMessageId = addMessage({\n            role: \"user\",\n            content: content.trim()\n        });\n        // Add assistant message placeholder\n        const assistantMessageId = addMessage({\n            role: \"assistant\",\n            content: \"\",\n            isStreaming: true\n        });\n        try {\n            // Filter out error messages and only include valid conversation messages\n            const conversationHistory = chatState.messages.filter((msg)=>!msg.content.startsWith(\"Error:\") && msg.content.trim() !== \"\").map((msg)=>({\n                    role: msg.role,\n                    content: msg.content\n                }));\n            // Add the new user message to conversation history\n            conversationHistory.push({\n                role: \"user\",\n                content: content.trim()\n            });\n            const stream = await (0,_utils_api__WEBPACK_IMPORTED_MODULE_1__.sendMessageToWeatherAgent)(conversationHistory, threadId);\n            let accumulatedContent = \"\";\n            await (0,_utils_api__WEBPACK_IMPORTED_MODULE_1__.parseStreamingResponse)(stream, {\n                onMessage: (contentChunk)=>{\n                    accumulatedContent += contentChunk;\n                    updateMessage(assistantMessageId, {\n                        content: accumulatedContent,\n                        isStreaming: true\n                    });\n                },\n                onFinish: ()=>{\n                    updateMessage(assistantMessageId, {\n                        content: accumulatedContent,\n                        isStreaming: false\n                    });\n                    setChatState((prev)=>({\n                            ...prev,\n                            isLoading: false\n                        }));\n                },\n                onError: (error)=>{\n                    updateMessage(assistantMessageId, {\n                        content: \"Error: \".concat(error),\n                        isStreaming: false\n                    });\n                    setChatState((prev)=>({\n                            ...prev,\n                            isLoading: false,\n                            error\n                        }));\n                }\n            });\n        } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : \"Failed to send message\";\n            updateMessage(assistantMessageId, {\n                content: \"Error: \".concat(errorMessage),\n                isStreaming: false\n            });\n            setChatState((prev)=>({\n                    ...prev,\n                    isLoading: false,\n                    error: errorMessage\n                }));\n        }\n    }, [\n        chatState.messages,\n        chatState.isLoading,\n        addMessage,\n        updateMessage\n    ]);\n    const clearChat = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setChatState({\n            messages: [],\n            isLoading: false,\n            error: null\n        });\n    }, []);\n    const searchMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((query)=>{\n        if (!query.trim()) return chatState.messages;\n        return chatState.messages.filter((message)=>message.content.toLowerCase().includes(query.toLowerCase()));\n    }, [\n        chatState.messages\n    ]);\n    return {\n        ...chatState,\n        sendMessage,\n        clearChat,\n        searchMessages,\n        addMessage,\n        updateMessage\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O3dCQUNEO2dCQUNEO1lBQ0Q7UUFDRCxFQUFFLE9BQU9BLE9BQU87WUFDZixNQUFNaUMsZUFBZWpDLGlCQUFpQmtDLFFBQVFsQyxNQUFNRSxPQUFPLEdBQUc7WUFDOURRLGNBQWNXLG9CQUFvQjtnQkFDakNMLFNBQVMsVUFBdUIsT0FBYmlCO2dCQUNuQlgsYUFBYTtZQUNkO1lBQ0F6QixhQUFhWSxDQUFBQSxPQUFTO29CQUNyQixHQUFHQSxJQUFJO29CQUNQVixXQUFXO29CQUNYQyxPQUFPaUM7Z0JBQ1I7UUFDRDtJQUNELEdBQUc7UUFBQ3JDLFVBQVVFLFFBQVE7UUFBRUYsVUFBVUcsU0FBUztRQUFFRTtRQUFZUztLQUFjO0lBRXZFLE1BQU15QixZQUFZM0Msa0RBQVdBLENBQUM7UUFDN0JLLGFBQWE7WUFDWkMsVUFBVSxFQUFFO1lBQ1pDLFdBQVc7WUFDWEMsT0FBTztRQUNSO0lBQ0QsR0FBRyxFQUFFO0lBRUwsTUFBTW9DLGlCQUFpQjVDLGtEQUFXQSxDQUFDLENBQUM2QztRQUNuQyxJQUFJLENBQUNBLE1BQU1uQixJQUFJLElBQUksT0FBT3RCLFVBQVVFLFFBQVE7UUFFNUMsT0FBT0YsVUFBVUUsUUFBUSxDQUFDMEIsTUFBTSxDQUFDdEIsQ0FBQUEsVUFDaENBLFFBQVFjLE9BQU8sQ0FBQ3NCLFdBQVcsR0FBR0MsUUFBUSxDQUFDRixNQUFNQyxXQUFXO0lBRTFELEdBQUc7UUFBQzFDLFVBQVVFLFFBQVE7S0FBQztJQUV2QixPQUFPO1FBQ04sR0FBR0YsU0FBUztRQUNabUI7UUFDQW9CO1FBQ0FDO1FBQ0FuQztRQUNBUztJQUNEO0FBQ0QsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaG9va3MvdXNlQ2hhdC50cz9iYTdiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgeyBNZXNzYWdlLCBDaGF0U3RhdGUgfSBmcm9tICdAL3R5cGVzJ1xyXG5pbXBvcnQgeyBzZW5kTWVzc2FnZVRvV2VhdGhlckFnZW50LCBwYXJzZVN0cmVhbWluZ1Jlc3BvbnNlIH0gZnJvbSAnQC91dGlscy9hcGknXHJcblxyXG5leHBvcnQgY29uc3QgdXNlQ2hhdCA9ICgpID0+IHtcclxuXHRjb25zdCBbY2hhdFN0YXRlLCBzZXRDaGF0U3RhdGVdID0gdXNlU3RhdGU8Q2hhdFN0YXRlPih7XHJcblx0XHRtZXNzYWdlczogW10sXHJcblx0XHRpc0xvYWRpbmc6IGZhbHNlLFxyXG5cdFx0ZXJyb3I6IG51bGxcclxuXHR9KVxyXG5cclxuXHRjb25zdCBhZGRNZXNzYWdlID0gdXNlQ2FsbGJhY2soKG1lc3NhZ2U6IE9taXQ8TWVzc2FnZSwgJ2lkJyB8ICd0aW1lc3RhbXAnPikgPT4ge1xyXG5cdFx0Y29uc3QgbmV3TWVzc2FnZTogTWVzc2FnZSA9IHtcclxuXHRcdFx0Li4ubWVzc2FnZSxcclxuXHRcdFx0aWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSxcclxuXHRcdFx0dGltZXN0YW1wOiBuZXcgRGF0ZSgpXHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHNldENoYXRTdGF0ZShwcmV2ID0+ICh7XHJcblx0XHRcdC4uLnByZXYsXHJcblx0XHRcdG1lc3NhZ2VzOiBbLi4ucHJldi5tZXNzYWdlcywgbmV3TWVzc2FnZV1cclxuXHRcdH0pKVxyXG5cdFx0XHJcblx0XHRyZXR1cm4gbmV3TWVzc2FnZS5pZFxyXG5cdH0sIFtdKVxyXG5cclxuXHRjb25zdCB1cGRhdGVNZXNzYWdlID0gdXNlQ2FsbGJhY2soKG1lc3NhZ2VJZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPE1lc3NhZ2U+KSA9PiB7XHJcblx0XHRzZXRDaGF0U3RhdGUocHJldiA9PiAoe1xyXG5cdFx0XHQuLi5wcmV2LFxyXG5cdFx0XHRtZXNzYWdlczogcHJldi5tZXNzYWdlcy5tYXAobXNnID0+IFxyXG5cdFx0XHRcdG1zZy5pZCA9PT0gbWVzc2FnZUlkID8geyAuLi5tc2csIC4uLnVwZGF0ZXMgfSA6IG1zZ1xyXG5cdFx0XHQpXHJcblx0XHR9KSlcclxuXHR9LCBbXSlcclxuXHJcblx0Y29uc3Qgc2VuZE1lc3NhZ2UgPSB1c2VDYWxsYmFjayhhc3luYyAoY29udGVudDogc3RyaW5nLCB0aHJlYWRJZD86IHN0cmluZykgPT4ge1xyXG5cdFx0aWYgKCFjb250ZW50LnRyaW0oKSB8fCBjaGF0U3RhdGUuaXNMb2FkaW5nKSByZXR1cm5cclxuXHJcblx0XHRzZXRDaGF0U3RhdGUocHJldiA9PiAoeyAuLi5wcmV2LCBpc0xvYWRpbmc6IHRydWUsIGVycm9yOiBudWxsIH0pKVxyXG5cclxuXHRcdC8vIEFkZCB1c2VyIG1lc3NhZ2VcclxuXHRcdGNvbnN0IHVzZXJNZXNzYWdlSWQgPSBhZGRNZXNzYWdlKHtcclxuXHRcdFx0cm9sZTogJ3VzZXInLFxyXG5cdFx0XHRjb250ZW50OiBjb250ZW50LnRyaW0oKVxyXG5cdFx0fSlcclxuXHJcblx0XHQvLyBBZGQgYXNzaXN0YW50IG1lc3NhZ2UgcGxhY2Vob2xkZXJcclxuXHRcdGNvbnN0IGFzc2lzdGFudE1lc3NhZ2VJZCA9IGFkZE1lc3NhZ2Uoe1xyXG5cdFx0XHRyb2xlOiAnYXNzaXN0YW50JyxcclxuXHRcdFx0Y29udGVudDogJycsXHJcblx0XHRcdGlzU3RyZWFtaW5nOiB0cnVlXHJcblx0XHR9KVxyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIEZpbHRlciBvdXQgZXJyb3IgbWVzc2FnZXMgYW5kIG9ubHkgaW5jbHVkZSB2YWxpZCBjb252ZXJzYXRpb24gbWVzc2FnZXNcclxuXHRcdFx0Y29uc3QgY29udmVyc2F0aW9uSGlzdG9yeSA9IGNoYXRTdGF0ZS5tZXNzYWdlc1xyXG5cdFx0XHRcdC5maWx0ZXIobXNnID0+ICFtc2cuY29udGVudC5zdGFydHNXaXRoKCdFcnJvcjonKSAmJiBtc2cuY29udGVudC50cmltKCkgIT09ICcnKVxyXG5cdFx0XHRcdC5tYXAobXNnID0+ICh7XHJcblx0XHRcdFx0XHRyb2xlOiBtc2cucm9sZSxcclxuXHRcdFx0XHRcdGNvbnRlbnQ6IG1zZy5jb250ZW50XHJcblx0XHRcdFx0fSkpXHJcblxyXG5cdFx0XHQvLyBBZGQgdGhlIG5ldyB1c2VyIG1lc3NhZ2UgdG8gY29udmVyc2F0aW9uIGhpc3RvcnlcclxuXHRcdFx0Y29udmVyc2F0aW9uSGlzdG9yeS5wdXNoKHtcclxuXHRcdFx0XHRyb2xlOiAndXNlcicgYXMgY29uc3QsXHJcblx0XHRcdFx0Y29udGVudDogY29udGVudC50cmltKClcclxuXHRcdFx0fSlcclxuXHJcblx0XHRcdGNvbnN0IHN0cmVhbSA9IGF3YWl0IHNlbmRNZXNzYWdlVG9XZWF0aGVyQWdlbnQoY29udmVyc2F0aW9uSGlzdG9yeSwgdGhyZWFkSWQpXHJcblx0XHRcdFxyXG5cdFx0XHRsZXQgYWNjdW11bGF0ZWRDb250ZW50ID0gJydcclxuXHJcblx0XHRcdGF3YWl0IHBhcnNlU3RyZWFtaW5nUmVzcG9uc2Uoc3RyZWFtLCB7XHJcblx0XHRcdFx0b25NZXNzYWdlOiAoY29udGVudENodW5rOiBzdHJpbmcpID0+IHtcclxuXHRcdFx0XHRcdGFjY3VtdWxhdGVkQ29udGVudCArPSBjb250ZW50Q2h1bmtcclxuXHRcdFx0XHRcdHVwZGF0ZU1lc3NhZ2UoYXNzaXN0YW50TWVzc2FnZUlkLCB7XHJcblx0XHRcdFx0XHRcdGNvbnRlbnQ6IGFjY3VtdWxhdGVkQ29udGVudCxcclxuXHRcdFx0XHRcdFx0aXNTdHJlYW1pbmc6IHRydWVcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRvbkZpbmlzaDogKCkgPT4ge1xyXG5cdFx0XHRcdFx0dXBkYXRlTWVzc2FnZShhc3Npc3RhbnRNZXNzYWdlSWQsIHtcclxuXHRcdFx0XHRcdFx0Y29udGVudDogYWNjdW11bGF0ZWRDb250ZW50LFxyXG5cdFx0XHRcdFx0XHRpc1N0cmVhbWluZzogZmFsc2VcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHRzZXRDaGF0U3RhdGUocHJldiA9PiAoeyAuLi5wcmV2LCBpc0xvYWRpbmc6IGZhbHNlIH0pKVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0b25FcnJvcjogKGVycm9yOiBzdHJpbmcpID0+IHtcclxuXHRcdFx0XHRcdHVwZGF0ZU1lc3NhZ2UoYXNzaXN0YW50TWVzc2FnZUlkLCB7XHJcblx0XHRcdFx0XHRcdGNvbnRlbnQ6IGBFcnJvcjogJHtlcnJvcn1gLFxyXG5cdFx0XHRcdFx0XHRpc1N0cmVhbWluZzogZmFsc2VcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHRzZXRDaGF0U3RhdGUocHJldiA9PiAoeyBcclxuXHRcdFx0XHRcdFx0Li4ucHJldiwgXHJcblx0XHRcdFx0XHRcdGlzTG9hZGluZzogZmFsc2UsIFxyXG5cdFx0XHRcdFx0XHRlcnJvciBcclxuXHRcdFx0XHRcdH0pKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSlcclxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XHJcblx0XHRcdGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0ZhaWxlZCB0byBzZW5kIG1lc3NhZ2UnXHJcblx0XHRcdHVwZGF0ZU1lc3NhZ2UoYXNzaXN0YW50TWVzc2FnZUlkLCB7XHJcblx0XHRcdFx0Y29udGVudDogYEVycm9yOiAke2Vycm9yTWVzc2FnZX1gLFxyXG5cdFx0XHRcdGlzU3RyZWFtaW5nOiBmYWxzZVxyXG5cdFx0XHR9KVxyXG5cdFx0XHRzZXRDaGF0U3RhdGUocHJldiA9PiAoeyBcclxuXHRcdFx0XHQuLi5wcmV2LCBcclxuXHRcdFx0XHRpc0xvYWRpbmc6IGZhbHNlLCBcclxuXHRcdFx0XHRlcnJvcjogZXJyb3JNZXNzYWdlIFxyXG5cdFx0XHR9KSlcclxuXHRcdH1cclxuXHR9LCBbY2hhdFN0YXRlLm1lc3NhZ2VzLCBjaGF0U3RhdGUuaXNMb2FkaW5nLCBhZGRNZXNzYWdlLCB1cGRhdGVNZXNzYWdlXSlcclxuXHJcblx0Y29uc3QgY2xlYXJDaGF0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG5cdFx0c2V0Q2hhdFN0YXRlKHtcclxuXHRcdFx0bWVzc2FnZXM6IFtdLFxyXG5cdFx0XHRpc0xvYWRpbmc6IGZhbHNlLFxyXG5cdFx0XHRlcnJvcjogbnVsbFxyXG5cdFx0fSlcclxuXHR9LCBbXSlcclxuXHJcblx0Y29uc3Qgc2VhcmNoTWVzc2FnZXMgPSB1c2VDYWxsYmFjaygocXVlcnk6IHN0cmluZykgPT4ge1xyXG5cdFx0aWYgKCFxdWVyeS50cmltKCkpIHJldHVybiBjaGF0U3RhdGUubWVzc2FnZXNcclxuXHRcdFxyXG5cdFx0cmV0dXJuIGNoYXRTdGF0ZS5tZXNzYWdlcy5maWx0ZXIobWVzc2FnZSA9PlxyXG5cdFx0XHRtZXNzYWdlLmNvbnRlbnQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhxdWVyeS50b0xvd2VyQ2FzZSgpKVxyXG5cdFx0KVxyXG5cdH0sIFtjaGF0U3RhdGUubWVzc2FnZXNdKVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0Li4uY2hhdFN0YXRlLFxyXG5cdFx0c2VuZE1lc3NhZ2UsXHJcblx0XHRjbGVhckNoYXQsXHJcblx0XHRzZWFyY2hNZXNzYWdlcyxcclxuXHRcdGFkZE1lc3NhZ2UsXHJcblx0XHR1cGRhdGVNZXNzYWdlXHJcblx0fVxyXG59XHJcblxyXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInNlbmRNZXNzYWdlVG9XZWF0aGVyQWdlbnQiLCJwYXJzZVN0cmVhbWluZ1Jlc3BvbnNlIiwidXNlQ2hhdCIsImNoYXRTdGF0ZSIsInNldENoYXRTdGF0ZSIsIm1lc3NhZ2VzIiwiaXNMb2FkaW5nIiwiZXJyb3IiLCJhZGRNZXNzYWdlIiwibWVzc2FnZSIsIm5ld01lc3NhZ2UiLCJpZCIsIkRhdGUiLCJub3ciLCJ0b1N0cmluZyIsInRpbWVzdGFtcCIsInByZXYiLCJ1cGRhdGVNZXNzYWdlIiwibWVzc2FnZUlkIiwidXBkYXRlcyIsIm1hcCIsIm1zZyIsInNlbmRNZXNzYWdlIiwiY29udGVudCIsInRocmVhZElkIiwidHJpbSIsInVzZXJNZXNzYWdlSWQiLCJyb2xlIiwiYXNzaXN0YW50TWVzc2FnZUlkIiwiaXNTdHJlYW1pbmciLCJjb252ZXJzYXRpb25IaXN0b3J5IiwiZmlsdGVyIiwic3RhcnRzV2l0aCIsInB1c2giLCJzdHJlYW0iLCJhY2N1bXVsYXRlZENvbnRlbnQiLCJvbk1lc3NhZ2UiLCJjb250ZW50Q2h1bmsiLCJvbkZpbmlzaCIsIm9uRXJyb3IiLCJlcnJvck1lc3NhZ2UiLCJFcnJvciIsImNsZWFyQ2hhdCIsInNlYXJjaE1lc3NhZ2VzIiwicXVlcnkiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useChat.ts\n"));

/***/ })

});